---
title: 컴퓨터 하드웨어 - 6. 메모리 (2편)
date: 2023-10-19 22:00:00 +0900
author: kimbob13
categories: [컴퓨터, 하드웨어]
tags: [computer, hardware, memory]
img_path: /assets/img/2023-10-19/computer-hardware-6-memory-2
math: true
---

## 1. DRAM

DRAM은 비휘발성 메모리 하드웨어로, CPU가 바로 접근할 수 있는 **메인 메모리**로 쓰이는 가장 핵심적인 메모리 하드웨어라고 할 수 있습니다. 직전 글에서 간단히 언급했듯 축전기를 기반으로 구현되어 있기 때문에 주기적인 **리프레시** 작업이 필요한 것이 특징입니다.

DRAM 또한 그 자체로 다양한 형태를 거치면서 지금까지 발전해왔고 현재도 발전 중에 있습니다. 이번 글에서는 DRAM의 간단한 작동 원리를 통해 발전 양상을 간단히 짚어보고, 더불어서 DRAM이 내부적으로 가지고 있는 계층 또한 알아보도록 하겠습니다.

### 1.1. 동기식과 비동기식

현재 PC든 모바일 기기든 대부분의 장치가 사용하는 DRAM은 **DDR SDRAM**이라는 방식으로 작동합니다. DDR과 SDRAM은 어떻게 보면 독립적인 기술이 한데 모인 것인데요, DRAM의 발전 과정을 보면 SDRAM이 DDR보다 먼저 개발되었습니다. 따라서 SDRAM이 무엇인지를 먼저 알아보도록 하겠습니다.

[**SDRAM (Synchronous DRAM)**](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory) 이란 단어 그대로 해석해보면 무언가와 **동기화**해서 작동하는 DRAM이라는 의미입니다. 이 Synchronous 부분이 바로 가장 먼저 알아볼 부분입니다. 아마 컴퓨터 분야를 공부해보신 분들은 **동기식 (Synchronous)**와 **비동기식 (Asynchronous)**라는 개념을 자주 접하셨을 것 같습니다. 근데 이 한세트의 개념은 소프트웨어 분야와 하드웨어 분야에서 뉘앙스가 조금 다른 편입니다.

이야기를 잠깐 새보면 소프트웨어 분야에서는 하나의 함수를 실행시켰을 때 **끝날 때까지 기다리는 것**을 동기식, 실행을 백그라운드로 시켜놓고 다른 작업을 수행하면서 원래 실행시킨 작업이 **끝날 때 알림을 받는 방식**을 비동기식이라고 표현합니다. 보통 시스템이 복잡해지면 복잡해질수록 비동기식으로 설계를 하여 성능 향상을 꾀하는 모습을 볼 수 있습니다.

![](software-sync-async.png){: w="500"}
_소프트웨어에서 동기식과 비동기식 ([출처](https://medium.com/from-the-scratch/wtf-is-synchronous-and-asynchronous-1a75afd039df))_

그에 반면 하드웨어 분야에서 동기식과 비동기식은 각각 어떤 하드웨어 모듈이 **외부에서 공급되는 클럭 신호와 동기화 되는가**를 의미합니다. 동기식이면 외부에서 공급되는 클럭 신호에 맞춰서 모듈의 동작이 결정되며, 비동기식이면 불규칙적으로 생성되는 신호에만 반응하여 동작한다는 의미가 됩니다.

![](hardware-sync-async.gif){: w="500"}
_하드웨어에서 동기식과 비동기식 개념 ([출처](https://people.eecs.berkeley.edu/~pattrsn/294/LEC9/lec.html))_

위의 그림이 조금 복잡할 수 있는데 눈여겨 볼 부분은 Synchronous 쪽에는 **Clock (CLK)** 신호가 추가되었다는 점입니다. 그에 따라 동기식은 실제 데이터가 (Dout 신호) 클럭 신호에 맞춰서 전송되고, 반면 비동기식은 불규칙적인 CAS 신호에 맞춰서 전송되는 것을 확인할 수 있습니다.

얼핏 보면 하드웨어에서도 필요할 때만 신호를 발생시켜서 데이터를 주고 받는 비동기식이 효율적인 것으로 보입니다. 하지만 비동기식 하드웨어 **이후에** 동기식이 개발되었다는 점은 동기식이 더 낫다는 거를 암시하겠죠[^1]. 실제로 하드웨어는 고속으로 동작할수록 **동기식이 일반적으로 더 좋은 성능**을 보여주게 됩니다. 저도 하드웨어 분야를 전공한 것은 아니라 자세한 메커니즘은 잘 모르기에 그렇다고만 정리하고 넘어가도록 하겠습니다.

### 1.2. DDR SDRAM

이제 SDRAM과 함께 묶이는 DDR을 알아보도록 하겠습니다. [**DDR (Double Data Rate)**](https://en.wikipedia.org/wiki/Double_data_rate)이란 단어 그대로 해석해보면 두배의 데이터 전송률 정도가 됩니다. 이 두배의 기준은 바로 **클럭 주기의 두배**라서 DDR은 클럭 신호가 있어야 비로소 의미있는 기술이라고 할 수 있습니다.

클럭 신호는 이전 CPU 파트에서 **전압**의 변화임을 설명드렸습니다. 조금 더 구체적으로 한 주기의 클럭 신호에는 전압이 오르는 순간과 떨어지는 순간이 한번씩 존재하는데요, 이를 각각 **상승 에지 (Rising Edge)**와 **하강 에지 (Falling Edge)**라고 부릅니다. DDR은 바로 상승 에지와 하강 에지 모두에서 데이터 전송이 이루어지는 것을 의미합니다. 그리고 반대로 상승 에지 (또는 하강 에지)에서만 데이터 전송이 이루어지는 기존 방식은 SDR (Single Data Rate)이라고 부릅니다.

![](ddr.png){: w="500"}
_SDR과 DDR_

여담으로 이미지에 보면 QDR도 등장하는데 이는 4분의 1주기 만큼 차이나는 두개의 클럭 신호를 통해 데이터를 전송하는 것을 확인할 수 있습니다. 메인 메모리에 쓰이는 DRAM보다는 흔히 그래픽카드라고 하는 GPU에 쓰이는 메모리인 GDDR SDRAM에 쓰이는 방식입니다.

DDR을 사용하게 되면 클럭 주파수와 실제 데이터 전송률 사이에 괴리가 생기게 됩니다. 한 클럭에 두번 데이터가 전송되니 실제 데이터 전송은 클럭 주파수의 2배가 되겠죠. 그래서 DDR에서는 클럭 주파수와 데이터 전송률을 구분하기 위해서 조금 다른 단위를 사용합니다.

클럭 주파수는 우리 모두에게 익숙한 **초당 몇회 진동**을 의미하는 **헤르츠 (Hz)**를 단위로 사용합니다. 1600MHz라면 초당 16억번 진동하는 클럭이라고 할 수 있는 것이죠. 그런데 DDR에서 데이터는 초당 32억번 데이터가 이동하게 됩니다. 그래서 이를 클럭과 구분하기 위해서 **초당 전송량 (Transfer per second, T/s)** 이라는 단위를 사용합니다. 즉 1600MHz의 클럭에서 데이터 전송률은 **3200MT/s**가 되는 것입니다.

그런데 보편적인 DRAM 상품 페이지를 가보면 이 데이터 전송률을 클럭인 것처럼 표기하는 경우가 많습니다. 즉 **3200MT/s가 맞는 상황에서 3200MHz**로 표기하는 것인데요. 엄밀히는 구분하는 게 좋겠지만 사실 이 맥락에서는 십중팔구 3200MHz는 3200MT/s를 의미하는 것이라서 딱히 헷갈릴 일이 많지는 않습니다. 대신 실제 컴퓨터 하드웨어 스펙을 별도 프로그램으로 확인할 경우 3200MHz (사실은 MT/s) 램은 1600MHz의 클럭 주파수를 가지고 있으니 이를 정직하게 보여주는 경우가 있습니다. 아래 예시도 윈도우의 작업 관리자는 MT/s 단위여야 할 것을 MHz로 보여주고 있고, 별도 프로그램은 원래 의미의 클럭 주파수를 보여주는 것을 알 수 있습니다.

![](ddr-frequency.png){: w="500"}
_윈도우 작업 관리자(왼쪽)와 별도 프로그램 (HWiNFO, 오른쪽)이 보여주는 DRAM 주파수_

DRAM은 DDR과 Synchronous 두가지 방식이 처음 개발된 이후 기본적으로는 이 원리로 동작하면서 클럭 주파수를 늘리는 방향으로 발전해 왔습니다. 그에 따라 다양한 버전들이 존재하는 데 첫 DDR SDRAM 이후로 2023년 현재는 **DDR5 SDRAM** 까지 등장한 상태입니다[^2]. 이들은 모두 SDRAM 방식이므로 보통은 간단하게 **DDR4**, **DDR5**와 같이 줄여서 부릅니다. 클럭 주파수가 늘어난다는 것은 곧 데이터 전송률이 늘어난다는 것일 텐데 이게 어떻게 이루어지는지를 간단히 살펴보겠습니다.

### 1.3. 대역폭 (Bandwidth)

데이터 전송률, 정확히 초당 데이터가 얼마나 많이 이동하는지는 컴퓨터에서 가장 중요한 성능 지표라고 할 수 있습니다. 결국 컴퓨터는 데이터에 연산을 하기 위한 장치인데 CPU와 메모리 사이의 데이터 이동이 빨라야 연산에 **병목**이 생기지 않을 것입니다. 

그래서 컴퓨터 분야에서는 초당 데이터 전송률을 **대역폭 (Bandwidth)**라고 하여 중요하게 다룹니다. 이 대역폭은 흔히 **속도 (Speed)**와 동일한 개념인 것처럼 소개하는 경우가 많은데, 일반 사용자 입장에서는 대역폭이 높으면 데이터 전송 속도가 빨라졌다는 걸 가장 직접적으로 느끼긴 하고 실제 단위도 초당 데이터 전송량으로 표기하니 맞는 말이긴 합니다.

다만 대역폭에는 **폭**이라는 개념이 들어있는 만큼 속도 뿐만 아니라 다른 중요한 요소도 들어가 있습니다. 그래서 대역폭을 설명할 때는 흔히 수도 배관을 예시로 드는데, 유속은 같은데 배관의 폭이 넓다면 초당 이동하는 물의 양은 실질적으로 더 많아질 것입니다. 즉 물의 이동 **속도**는 동일한데, **폭이 늘어나서** 물이 전달되는 속도가 빨라진다고 느끼는 것입니다.

![](bandwidth.png){: w="500"}
_수도 배관을 예시로 한 대역폭_

그런데 중요한 건 실제 **물의 이동 속도**가 늘어난 것은 아니라는 것입니다. 다만 초당 이동할 수 있는 물의 양, 즉 배관의 폭이 증가했기 때문에 결과적으로 속도가 빨라진 것인데요. 이 폭이 늘어나는 게 왜 중요한지를 전자공학 관점에서도 알아보겠습니다.

대역폭이라는 것은 본질적으로 데이터를 주고 받는 상황에서 의미가 있는 수치인 만큼 주는 쪽과 받는 쪽이 존재해야 합니다. 이렇게 데이터를 주고 받는 상황이 바로 우리 모두에게 익숙한 **통신 (Communication)** 상황인데요, 여기서는 통신의 가장 대표적인 예인 전화 통화를 예로 들겠습니다.

전화 통화를 하는 상황을 생각해보면 하나의 통신망 안에서 얼마나 빠르게 서로의 말을 주고 받는지도 중요하겠지만, **얼마나 많은** 수신자와 발신자 쌍을 동시에 처리할 수 있는지도 중요한 요소입니다. 사실 일대일 상황만 보면 내가 말한 게 상대방에게 0.1초만에 도달하든 0.2초만에 도달하든 큰 차이를 느끼긴 힘들 겁니다. 그래서 전화를 위한 통신망은 일대일로만 보면 데이터 전송 속도가 아주 최첨단으로 빠를 필요는 없습니다.

그런데 10쌍 (즉 20명)이 같은 통신망에서 전화할 때 누구는 10초 뒤에 전달되고, 누구는 0.5초 뒤에 전달되는 등 차이가 극명하면 불만이 폭주하겠죠. 이렇게 통신망을 동시에 사용할 때도 모두가 **동일한 서비스 품질**을 느끼려면 모두가 가령 0.1초에 데이터가 오고 가는 걸 보장할 만큼 통신망의 **데이터 전송률이 충분**해야 합니다.

설명이 어려웠는데 쉽게 말해서 일대일 통신에서 10의 품질이면 충분하다고 할 때 10쌍이 모두 10의 품질을 느끼려면 통신망은 도합 100의 품질을 보장해야 한다는 것입니다. 이것이 바로 대역폭이 속도 이외에 가지고 있는 의미라고 할 수 있습니다. 

컴퓨터 분야에서 데이터는 비트와 바이트 단위로 전송되므로 대역폭은 곧 초당 전송되는 비트 혹은 바이트 수로 정의합니다. 비트를 사용하는 경우에는 **bps (bit per second)**, 바이트를 사용하는 경우에는 **B/s (Byte per second)**와 같이 표현하는 것이 일반적입니다. B의 대소문자 구분에 주의해야 하는데 모두 잘 알고 계시듯이 1Byte = 8bit 이므로 bps와 B/s의 차이는 8배이기 때문입니다.

이 단위가 1000배가 되면 Kbps (바이트면 KB/s), 백만배가 되면 Mbps (역시 MB/s)와 같이 표시하게 됩니다. 여담으로 사실 모든 대역폭은 bps, 혹은 B/s 하나로 표현해도 맞는 거긴 한데 분야에 따라 bps를 선호하기도 하고 B/s를 선호하기도 합니다. 일반적으로 컴퓨터 네트워크 분야에서는 bps를 많이 사용하는데 대부분 인터넷 속도는 1Gbps, 100Mbps와 같이 표현하는 것을 보셨을 것입니다. 또 USB 표준에서 전송 속도를 다룰 때도 bps 단위를 사용합니다.

반대로 인터넷에서 파일을 다운로드 받을 때의 속도라던가, 저장 장치의 속도 같은 걸 얘기할 땐 B/s를 주로 사용합니다. 그래서 가령 1Gbps 인터넷에서 파일을 다운받는다고 하면 브라우저 같은 데서 볼 수 있는 최대 수치는 125MB/s가 될 것입니다[^3]. 이 글에서 계속 얘기할 DRAM의 대역폭 또한 주로 B/s 단위를 사용하니까 참고하면 좋을 것 같습니다.

### 1.4. DRAM의 작동 속도

다시 DRAM으로 돌아와서 본격적으로 DRAM의 작동 속도를 다루도록 하겠습니다.

앞서 DRAM은 DDR SDRAM 방식이 사용된 이후로 클럭 주파수를 늘리는 방향으로 발전해왔다고 했고 이는 곧 DRAM이 지원하는 대역폭의 증가를 의미할 것입니다. 그런데 단순히 DRAM의 주파수라고만 하면 다소 함정이 있습니다. 왜냐하면 DRAM이 실제로 동작하는 주파수와 DRAM 모듈 외부와 CPU가 데이터를 주고 받는 주파수가 **서로 다르기 때문입니다**. 무슨 말인지 알기 위해선 DRAM 모듈이 어떻게 이루어졌는지를 조금 들여다볼 필요가 있습니다.

#### 1.4.1 DRAM 모듈 엿보기

![](dram.png){: w="500"}
_DRAM 모듈_

DRAM 모듈을 보면 길쭉한 기판 위에 같은 크기의 검은색 칩들이 여러개 박혀있는 모습을 볼 수 있습니다[^4]. 실제 DRAM은 바로 이 검은색 칩 하나 하나를 의미합니다. 그런데 이 개개의 칩들은 물리적인 한계 때문에 주파수를 무작정 높이는 것이 어렵다고 합니다.

하지만 그렇다고 하여 나날이 빨라져만 가는 CPU와 보조를 맞추려면 DRAM이 CPU와 통신하는 속도에는 발전이 필요합니다. 그래서 DRAM 모듈은 내부에 **버퍼**를 두어 여러 DRAM 칩[^5]에서 동시에 데이터를 꺼내온 다음에 CPU에는 이 버퍼에 있는 데이터를 전달하게 됩니다. 이러면 버퍼에 있는 여러 데이터가 한번에 CPU로 전달될 것이니 CPU와의 **유효 (Effective)** 대역폭은 DRAM 칩 하나의 대역폭보다 높아질 것입니다.

![](dram-buffer.png){: w="400"}
_DRAM 내부의 버퍼_

위 그림을 보면 DRAM 칩 (DRAM Cell Array 부분)과 I/O 버퍼는 $f$의 클럭으로 작동하지만 모듈 외부로는 DDR이기 때문에 같은 $f$ 클럭이어도 **한 클럭에 데이터가 두번** 나가는 모습을 확인할 수 있습니다. 이렇게 동작하는 DRAM이 바로 첫번째 버전의 DDR SDRAM이고 그래서 현재는 **DDR1** 이라는 이름으로 주로 부릅니다.

DDR1의 경우 두곳에서 데이터를 꺼내와서 버퍼에 저장하는데, 여기서 한곳에서 꺼내오는 데이터의 크기 또한 중요한 요소입니다. 즉 DRAM 칩과 버퍼 사이의 화살표 하나가 나타내는 데이터의 크기를 의미하는데, DDR SDRAM의 경우 통상 **64bit (=8B)**를 사용합니다. 처음 나온 DDR1의 작동 클럭 $f$는 100MHz 였는데요, 이를 바탕으로 CPU와 초당 주고 받는 대역폭을 계산해보면 다음과 같습니다.

$$2 \times 8B \times 100M /s = 1600 MB/s$$

이 8B의 데이터 크기는 DDR1 뿐만 아니라 이후에 등장하는 모든 DDR SDRAM에 동일한 부분입니다. 그래서 특정 클럭으로 작동하는 DRAM을 이 **대역폭 수치를 통해서 구분**하기도 하는데요, 관련 부분은 이후에 DRAM의 표준을 다루면서 얘기하겠습니다.


#### 1.4.2 DDR1 이후와 Prefetch 기법

DDR1은 그래도 DRAM 모듈 내외부의 작동 클럭이 동일합니다. 다만 DDR이라서 DRAM 외부에서는 한 클럭 사이클에 두번 데이터가 나갈 뿐인 거죠. 하지만 CPU와 데이터를 주고받는 대역폭을 높이기 위해선 클럭이 높아져야 하는데, DRAM 칩의 클럭을 올리기는 어려우니 엔지니어들은 **밖에 나가는 클럭**, 즉 CPU와 소통하는 클럭을 높이는 방향을 선택합니다.

근데 여기서 가령 외부의 클럭을 2배로 올린다고 하면 버퍼는 한번에 얼마나 많은 데이터를 DRAM 칩에서 가져와야 할까요? DDR이라서 DRAM 칩과 외부 클럭이 같을 땐 2곳에서 가져왔으니, 이 클럭만 두배가 된다면 **4곳**에서 동시에 가져와야 할 것입니다. 이것이 바로 DDR1의 다음 버전인 **DDR2 SDRAM** 의 작동 방식입니다.

![](ddr2-sdram.png){: w="400"}
_DDR2 SDRAM_

보면 버퍼와 외부 클럭은 DRAM 칩의 2배가 된 것을 알 수 있습니다. 다음 세대인 DDR3는 이 클럭이 4배가 되므로 I/O 버퍼에는 동시에 **8곳**에서 데이터를 가져오게 됩니다. 이렇게 버퍼에 한번에 여러 데이터를 저장해두는 것을 [**Prefetch**](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory#PREFETCH)라고 부르며, 그에 따라 DDR3 같은 경우에는 **"prefetch size가 8n이다"**와 같은 식으로 표현합니다.

하지만 버퍼 또한 하드웨어이기 때문에 prefetch size를 무한정 늘리기는 힘듭니다. 그래서 이후 나온 DDR4는 DDR3와 동일하게 8n의 prefetch size를 사용합니다. 대신 DDR4는 다른 방식을 통해 대역폭을 늘리게 되는데 여기서부터는 본 포스트의 취지와는 많이 벗어나므로 생략하도록 하겠습니다. 어쨌든 중요한 것은 최신 DDR5까지 오면서 대역폭은 계속 증가해오고 있지만 이는 단순히 DRAM 칩의 작동 클럭을 올리는 것이 아닌 **Prefethc 기법을 포함하여 다양한 기법을 사용**해서 이루어진다는 것입니다.

## 2. DRAM 계층

앞서 DRAM의 작동 속도를 설명하기 위해 DRAM 모듈을 살짝 엿봤는데요, 여기서는 이 DRAM 모듈이 **어떤 계층**을 가지고 구성되어 있는지 좀 더 자세히 알아보도록 하겠습니다.

DRAM은 대역폭, 용량 등 다양한 스펙 요소를 발전시키기 위해 **계층 구조**를 가지고 있습니다. 아래는 DRAM의 계층을 묘사한 그림입니다.

![](dram-hierarchy.png){: w="500"}
_DRAM 계층 구조_

그림에서 나오는 Chip이 앞서 계속 얘기했던 DRAM 칩, 즉 DRAM 모듈 위에 있었던 검은색 사각형 하나라고 보셔도 무방합니다. 따라서 본 포스트에서는 칩의 하위에 나오는 Bank나 Row/Column은 다루지 않을 것이며, 최상단에 등장하는 Channel과 DIMM을 위주로 다루도록 하겠습니다.

### 2.1. 채널

**채널 (Channel)**은 DRAM 계층의 최상단에 위치한 구성요소입니다. 먼저 채널이라는 용어 자체는 정말 다양한 분야에서 활용하는 용어인데요, 컴퓨터 분야에서 보편적으로 쓰이는 의미는 **독립적으로 데이터를 주고 받을 수 있는 통로** 정도로 생각해도 무방합니다.

여기서 독립적이라는 의미는 만약 채널이 여러개 있다면 한 채널이 다른 채널의 데이터 전송에 영향을 미치지 않는다는 의미입니다. 도로로 예를 들면 경기도 이천시와 하남시 사이를 연결하는 중부고속도로와 제2중부고속도로의 관계 같은 것이라고 보시면 됩니다. 잘 아시겠지만 이 두 도로는 같은 구간을 잇지만 완전히 독립적으로 개통되어 있어서 한 도로에서 다른 도로로 이동하는 게 불가능한데요, 컴퓨터의 채널 또한 이런 개념이라고 보시면 됩니다.

![](jungbu-highway.png){: w="500"}
_중부고속도로와 제2중부고속도로 하남 인근 분기점 지도_

앞서 DRAM의 대역폭을 살펴보았을 때는 DRAM 모듈 하나가 가지는 대역폭을 살펴보았습니다. 모듈이 하나니까 하나의 채널에서 CPU와 데이터를 주고 받을 수 있는 대역폭이라고도 할 수 있는데요. 그러면 이 채널이 2개로 늘어나면 어떻게 될까요? 채널은 서로 독립적인 통로니까 이론적으로는 두 채널의 대역폭을 합쳐서 2배의 대역폭으로 CPU와 데이터를 주고 받을 수 있게 됩니다.

그러면 이론적인 거니까 실제는 다르겠네요? 라고 생각하실 텐데, 의외로 이건 **정직하게 2배**가 됩니다. 그러면 3200MT/s의 데이터 전송률을 가지는 DRAM이 2개의 채널로 연결되어 있을 때의 최대 대역폭을 계산해보면 다음과 같습니다.

$$ 8B \times 3200MT/s \times 2 = 51,200MB/s $$

이 채널 개수는 CPU에서 그 개수만큼 지원을 해주어야 합니다. 즉 2개 채널에서 메모리를 사용하고 싶다면 CPU가 2개 채널을 지원해야 한다는 것입니다. 이 채널 개수는 CPU의 나름 중요한 스펙이기 때문에 인텔이든 AMD든 제품 스펙에 지원 채널 수를 기재해 둡니다. 채널 2개의 경우 보통 **듀얼 채널 (Dual Channel)**이라고 부르는데, 2010년대 이후로 여러분이 조립 PC를 구매한다고 하면 99% 이상은 듀얼 채널을 지원하는 CPU로 구매하게 될 것입니다.

![](memory-channel.png){: w="500"}
_인텔 코어 i9-13900K CPU의 메모리 채널 스펙_

여담으로 소비자용 CPU의 경우에는 대부분 2개의 채널만 지원하지만 서버나 고급 사용자용 CPU의 경우에는 4개에서 8개의 채널까지 지원하는 경우도 있습니다. 이런 컴퓨터들은 **메모리 대역폭에서 병목이 오지 않는 게 중요**하기 때문에 그런 것인데, 그래서 그 만큼 CPU 자체의 가격도 (물론 다른 요소도 있지만) 딱히 일반인이 접근하기 쉬운 가격대는 아닙니다.

### 2.2. DIMM

다음은 채널보다 한단계 아래 계층에 위치한 DIMM이라는 것입니다. DIMM은 **Dual In-line Memory Module**의 약자인데요, 이름에 메모리 모듈이 들어가 있습니다. 제가 앞서 **DRAM 모듈**이라는 용어를 계속 사용했었는데, 바로 이 DIMM이 이 모듈의 정확한 이름이라고 할 수 있습니다.

즉 여러분이 시중에서 구할 수 있는 길쭉한 기판에 검은색 칩이 박힌 모듈은 사실상 전부 이 DIMM인 것입니다. 이 DIMM이 기술적인 부분 이외에 소비자에게도 나름 중요한 역할을 하는 것이 하나 있는데 바로 **단자의 모양**입니다. 무슨 말이냐 하면 앞서 현대 DRAM들은 모두 DDR SDRAM의 발전형이고, 그에 따라 DDR1, 2와 같이 버전이 나눠져 있다고 했는데요. 근데 이 버전은 서로 **호환이 되지 않기** 때문에 섞어서 쓰는 것이 불가능합니다.

그래서 DRAM 제조사는 서로 다른 버전의 DDR SDRAM이 혼용되는 것을 막기 위하여 이 DIMM의 단자 모양을 버전 별로 조금씩 바꿉니다. 모듈을 보면 보드에 꽂는 금박 부분에 조그마하게 구멍이 하나 나 있는 것을 확인할 수 있는데, 이 **구멍이 뚫린 위치가 DDR 버전마다 조금씩 달라지게** 됩니다. 그래서 가령 DDR3만 지원하는 컴퓨터에서는 아예 DDR4 램이 꽂히지 않게 되는 것입니다.

![](dimm-slot.png){: w="500"}
_DDR 버전 별로 서로 다른 DIMM 슬롯의 모양_

계층 관점에서 DIMM은 채널보다 하위에 있기 때문에 한 채널에 다수의 DIMM이 장착될 수 있습니다. 근데 거의 모든 PC는 한 채널에 두개의 DIMM을 장착하는 것을 지원합니다. 소비자용 CPU는 채널도 보통 듀얼 채널을 지원한다고 했으니, 꽂을 수 있는 DRAM 모듈의 개수는 총 4개가 되고 실제로도 아주 저가형 보드가 아닌 이상 대부분 4개의 램 슬롯을 갖추고 있는 것을 확인할 수 있습니다.

마지막으로 이 DIMM은 실제로 봐도 꽤 길쭉하기 때문에 노트북 같이 제한된 환경에서 사용하기에는 애로사항이 있습니다. 그래서 이 DIMM의 사이즈를 줄인 **SO-DIMM (Small Outline DIMM)**이라는 것도 존재합니다. 아마 PC 부품 구매 사이트에 가보면 대부분 **노트북용 메모리**라는 이름으로 카테고리가 구분되어 있을 텐데, 바로 이 SO-DIMM 형태의 모듈을 의미합니다.

![](dimm-sodimm.jpg){: w="500"}
_DIMM과 SO-DIMM_


### 2.3. 그 외 계층

그 외에도 DIMM 하위에 Rank, Chip 등의 다양한 계층이 존재하는데요, 앞서 설명드렸듯 Chip부터 그 아래 계층은 DRAM 칩 자체의 구조 이해가 필요하기 때문에 여기서는 생략하겠습니다.

그러면 그 중간에 Rank는 무엇인가 할 수 있을 텐데요, 일반 사용자에게 큰 영향을 미치는 부분은 아니라 간단하게만 짚고 넘어가겠습니다. DRAM 모듈을 보면 어떤 건 칩이 조금 박혀 있고, 어떤 건 많이 박혀 있는 모습을 확인할 수 있는데요. 보통은 칩의 개수가 늘어나면 해당 모듈이 가지는 전체 메모리 용량도 늘어나게 됩니다[^6].

그런데 칩이 늘어나면 늘어날수록 이 또한 하드웨어 제약 때문에 하나의 어떤 라인[^7]에 모두 연결하는 데 한계가 있어서 이를 계층을 두어 여러 라인으로 분리할 필요가 생깁니다. 그에 따라 생기는 계층이 바로 **랭크 (Rank)**라는 것입니다. 그래서 DRAM 칩이 많이 박힌 모듈을 보면 모듈의 양쪽 면에 모두 칩이 존재하는 경우가 있습니다. 이런 램을 약간 컴퓨터 은어이긴 하나 **양면 램**이라고 주로 부르고 그렇지 않은 건 **단면 램**이라고 부르게 되는데요. 항상 그렇지는 않지만 보통 양면 램인 경우엔 랭크가 두개, 아니면 한개인 경우가 일반적입니다[^8].

![](dram-rank.jpg){: w="500"}
_단면 램과 양면 램_

## 3. JEDEC 표준

마치기에 앞서 DRAM 관련 스펙을 접할 때 알아두면 좋은 표준 내용에 관하여 언급해 보겠습니다.

DRAM 또한 여타 표준들처럼 여러 기기에서의 호환성을 보장하고자 일종의 표준에 맞춰져서 만들어집니다. DDR SDRAM의 모든 버전 또한 이 표준 안에서 만들어지는 것인데요, DRAM이 사용하는 표준안의 이름은 **JEDEC 표준**이라고 부릅니다.

[JEDEC](https://www.jedec.org/)은 Joint Electron Device Engineering Council의 약자로 반도체 분야의 저명한 단체 중 하나입니다. DRAM 뿐만 아니라 다양한 반도체 장비의 표준안을 제정하고 있는데요, 그 많은 표준안 중 하나에 DRAM을 위한 표준안이 존재하는 것입니다.

DRAM의 JEDEC 표준에서 알아두면 좋은 부분은 크게 두가지가 있는데 하나는 작동 주파수이고, 다른 하나는 소위 **램 타이밍**이라고 불리는 수치들입니다. 이들을 하나씩 간단히 알아보겠습니다.

### 3.1. 표준 주파수

먼저 이야기를 시작하기에 앞서 위키피디아에서 발췌한 DDR4 SDRAM의 JEDEC 표준을 살펴보겠습니다.

![](ddr4-jedec.png){: w="500"}
_DDR4 JEDEC 표준_

표를 보면 상단에 이름부터 해서 다양한 항목들이 존재하는 것을 알 수 있습니다. 이 중에서 clock과 rate과 관련된 부분은 이번 포스트에서 전부 설명을 드린 것들입니다. Memory clock은 바로 DRAM 칩의 클럭을 의미하고, I/O bus clock은 DRAM 모듈과 CPU 사이의 클럭을 의미하며, Data rate은 DDR이니까 I/O bus clock의 두배 수치를 적어놓은 것입니다. 마지막으로 Peak transfer rate이 바로 data rate을 8B만큼 곱한 대역폭을 의미합니다.

앞서 대역폭 설명 말미에 대역폭 수치가 DRAM 표준 이름에 영향을 미친다고 했는데요. 보면 첫번째 열의 표준 이름은 Data rate과 동일한 것 같고, Module name은 대역폭 수치와 동일한 것으로 확인됩니다. 실제로 DRAM의 JEDEC 표준 이름은 바로 이들을 통해 정해지며, 흔히 **DDR<버전>-<Data rate>** 혹은 **PC<버전>-<대역폭>**의 수치로 표현합니다.

그래서 3200MT/s를 가지는 DDR4 SDRAM의 경우 **DDR4-3200** 혹은 **PC4-25600**과 같은 이름을 가지게 됩니다. 따라서 이들 이름만 보고 이 램이 어느 정도의 성능을 가질지를 예측할 수 있게 됩니다.

### 3.2. 램 타이밍

표준에서 발 수 있는 두번째 요소는 타이밍입니다. 표에 보면 표준 이름 뒤쪽에 다양한 알파벳이 붙기도 하는데 (DDR4-3200**AA**), 이들은 램 타이밍에 따라 달라지는 부분입니다. 램 타이밍은 DRAM의 데이터를 올바르게 접근하기 위해 CPU가 지켜줘야 하는 시간이라고 할 수 있는데, 당연히 낮을 수록 CPU가 접근하는 데 필요한 시간은 줄어들게 됩니다.

다만 이 타이밍은 클럭과 반비례하는 관계에 있어 같이 좋아지기는 어렵고 보통 클럭이 오르면 타이밍 값도 늘어나게 됩니다. 그러나 또 이 타이밍 수치라는 게 절대적인 시간 (초 단위)이 아니라 **클럭 주기가 몇 주기 필요한지**의 수치입니다. 즉 DDR4-3200AA 같은 경우 타이밍이 22로 적혀 있는데 1600MHz 클럭의 22 주기가 필요하다는 의미입니다. 1600MHz의 한 주기는 대략 0.625ns이므로 22 주기는 13.75ns 정도가 될 것입니다. 이것이 바로 가장 마지막 열에 있는 CAS latency의 의미입니다.

이걸 다르게 생각해보면 클럭이 늘어나면 클럭 한 주기에 필요한 시간이 줄어들게 됩니다. 그래서 타이밍 값이 늘어난다 한들 실제로 필요한 시간 자체는 줄어든 클럭 주기 때문에 크게 차이가 나지 않는다는 것입니다. 실제로 표를 확인해봐도 DDR4-1600 램들과 DDR4-3200 램들의 CAS latency 값은 동일한 것을 알 수 있습니다. 그래서 일반적으로 램을 살 때는 굳이 타이밍 수치를 딱히 고려할 필요가 없게 됩니다[^9].

## 4. 정리

드디어 메모리 부분까지도 모두 알아보았습니다. 메모리가 어떤 역할을 하는지에서부터 종류, 그리고 메인 메모리의 핵심인 DRAM이 어떻게 동작하고 중요한 스펙 요소가 무엇인지, 마지막으로 DRAM과 관련된 JEDEC 표준까지 알아보았습니다.

역시나 CPU처럼 최대한 어려울 수 있는 부분은 제외하면서 조금 깊게 알면 좋을 내용들을 다루고자 노력하였지만 설명이 뭔가 중구난방으로 길어지기만 한 것 같습니다.. 게다가 확실히 짬을 내서 써야 하다 보니 요근래 시간이 없어서 지난 글과의 시간 차이가 무려 한달이 되어 버렸습니다. 뭐든지 계획대로 한다는 게 참 쉽지 않다는 걸 다시금 깨닫습니다.

아무튼 다음 파트에서는 메인보드를 다루고자 하는데요, 여기서는 이론적인 내용보다는 실제 하드웨어를 구매할 때 알아두면 잡다한 지식들을 주로 다루게 될 것 같습니다. 언제나 그렇듯 계획대로 될지는 모르겠지만.. 아무튼 저는 다음 글에서 다시 찾아 뵙도록 하겠습니다. 감사합니다.

---

[^1]: 물론 모든 기술 발전이 항상 더 나은 방향으로 이루어지는 것은 아닙니다만 많은 경우에는 그렇다고 할 수 있겠죠.
[^2]: 첫 DDR SDRAM은 처음 나왔을 땐 그냥 DDR SDRAM이라고 불렀지만 이후 버전 구분을 위해 DDR1 이라고 부르는 경우도 있습니다.
[^3]: 당연히 여러 현실적인 이유로 이 속도가 계속 나오는 건 아니지만 문제가 있는 게 아니라면 110MB/s 이상은 나올 것입니다.
[^4]: 보통 이 기판 색이 초록색인데 (검은색이나 드물게 파란색도 있긴 합니다), 그래서 하드웨어 커뮤니티에서는 이런 형태의 램을 **시금치 램**이라고 부르기도 합니다.
[^5]: DRAM 내부도 꽤 계층화가 많이 이루어져 있기 때문에 정확히 칩 단위일지는 확실하지는 않습니다. 요지는 여러 DRAM 주소에 위치한 데이터를 동시에 꺼내온다는 것입니다.
[^6]: 물론 칩 하나의 용량이 다를 수도 있어서 무조건 그렇지는 않습니다.
[^7]: 하드웨어 분야에서는 **Chip Select (CS)** 라는 신호로 불립니다.
[^8]: 항상 그렇지는 않기에 단면 램인데 랭크가 2개일 수도, 양면 램인데 랭크가 하나일 수도 있습니다. 요지는 랭크는 칩의 개수에 영향을 받는 것이고, 단면, 양면 여부는 부차적인 효과라는 것입니다.
[^9]: 근데 같은 주파수에서 타이밍 값을 줄이는 데 성공하면 전반적인 성능은 더 오를 것입니다. 예를 들어 DDR4-3200 램의 타이밍을 22에서 16과 같이 줄이는 상황인데요, 하드 코어 게이머들은 이 타이밍에도 민감하기 때문에 고려를 하는 경우가 아주 없지는 않습니다.